<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
<meta name="keywords" content="深度优先,管星,xguan2014,.Net Core,C#,程序员,.Net博客,xguan,树莓派">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/themes/blue/pace-theme-minimal.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.bfsdfs.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":100},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="一份耕耘，一份收获">
<meta property="og:type" content="website">
<meta property="og:title" content="深度优先">
<meta property="og:url" content="http://blog.bfsdfs.com/page/9/index.html">
<meta property="og:site_name" content="深度优先">
<meta property="og:description" content="一份耕耘，一份收获">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Mr.Guan">
<meta property="article:tag" content="深度优先">
<meta property="article:tag" content="管星">
<meta property="article:tag" content="xguan2014">
<meta property="article:tag" content=".Net Core">
<meta property="article:tag" content="C#">
<meta property="article:tag" content="程序员">
<meta property="article:tag" content=".Net博客">
<meta property="article:tag" content="xguan">
<meta property="article:tag" content="树莓派1">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://blog.bfsdfs.com/page/9/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>深度优先</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?7d4b9c409d6a4f7ccb3245af7b784a46";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">深度优先</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">这个家伙好懒，除了文章什么都没留下</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-tools">

    <a href="/tools/" rel="section"><i class="wrench fa-fw"></i>工具</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.bfsdfs.com/2020/10/02/%E3%80%90VS%E3%80%91%E5%87%A0%E4%B8%AA%E8%B6%85%E7%BA%A7%E5%AE%9E%E7%94%A8%E4%BD%86%E5%BE%88%E5%B0%91%E4%BA%BA%E7%9F%A5%E9%81%93%E7%9A%84%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="Mr.Guan">
      <meta itemprop="description" content="一份耕耘，一份收获">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="深度优先">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/02/%E3%80%90VS%E3%80%91%E5%87%A0%E4%B8%AA%E8%B6%85%E7%BA%A7%E5%AE%9E%E7%94%A8%E4%BD%86%E5%BE%88%E5%B0%91%E4%BA%BA%E7%9F%A5%E9%81%93%E7%9A%84%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">【VS】几个超级实用但很少人知道的技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-02 17:51:22" itemprop="dateCreated datePublished" datetime="2020-10-02T17:51:22+08:00">2020-10-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">常用工具</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>大家好，今天分享一些实用的 VS 技巧，而这些技巧我发现很多人都不知道。因为我经常在工作中遇到：我在同事电脑上解决问题，或在会议上演示代码示例时，使用了一些 VS “骚”操作，他们会好奇地问：你是怎么做到的？有时候你知道一些别人不知道的小技巧便可以让你显得更专业。</p>
<p>PS：本文所有示例演示均基于 Visual Studio 2019 v16.7.4 版本。</p>
<h2 id="扩展-缩小选区"><a href="#扩展-缩小选区" class="headerlink" title="扩展/缩小选区"></a><strong>扩展/缩小选区</strong></h2><p>通过双击选中整个单词，这个操作大家应该都知道。但如何快速选择几个单词、或多个单词的字符串、或代码块呢？教大家一个快捷键，如何快速扩展选择代码区域。例如，当光标在一个字符串中时，使用下面的快捷键就可以选择整个字符串。</p>
<p>按 <code>Alt</code> + <code>Shift</code> + <code>=</code> 扩展选区，按 <code>Alt</code> + <code>Shift</code> + <code>-</code> 缩小选区：</p>
<p><img src="/images/v2-814e7c9dcd5238d1c85ad6aa55f85668_b.gif" alt=""></p>
<p>你也可以使用 <code>Alt</code> + <code>Shift</code> + <code>]</code> 直接选中一个代码块。</p>
<h2 id="切换窗口停靠"><a href="#切换窗口停靠" class="headerlink" title="切换窗口停靠"></a><strong>切换窗口停靠</strong></h2><p>我们知道VS的窗口布局可以非常灵活的拖动，想摆哪摆哪。我们一般把常用的视图窗口固定停靠在编辑器的左边、右边或下边。但有时候为了查看方便，你可能需要临时把窗口拖到另一个位置（比如中心位置）。完了以后你还需要再次把它停靠到原来的位置，这样拖动起来就会比较麻烦。有一种非常快速的方法可以将窗口停靠到它之前停靠的位置。</p>
<p>按 <code>Ctrl</code> + 双击窗口标题：</p>
<p><img src="/images/v2-867b4832325c2be15f02fc7a2a926fae_b.gif" alt=""></p>
<h2 id="快速定位打开的文件"><a href="#快速定位打开的文件" class="headerlink" title="快速定位打开的文件"></a><strong>快速定位打开的文件</strong></h2><p>在 VS 中，你可以使用 <code>Ctrl</code> + <code>T</code> 打开 “Go To All” 搜索工具栏，通过搜索关键字轻松打开要找的文件。但是对于某些操作，比如重命名文件，你需要在解决方案资源管理器中找到该文件。</p>
<p>使用 <code>Ctrl</code> + <code>[</code>, <code>S</code> 或使用下面的图标按钮可以快速定位到当前打开的文件：</p>
<p><img src="/images/v2-ffe161b22ceab1b3e73bc36d7ec50ea2_b.gif" alt=""></p>
<h2 id="多行编辑"><a href="#多行编辑" class="headerlink" title="多行编辑"></a><strong>多行编辑</strong></h2><p>Visual Studio 允许同时编辑多行，这对于将相同的更改应用于多行非常有用，例如同时修改多个属性的修饰符。下面有 4 个多行编辑代码的技巧。</p>
<p>按住 <code>Alt</code> 键，使用鼠标拖选：</p>
<p><img src="/images/v2-4035b6131a1a83be20c9cbe8be1671bd_b.gif" alt=""></p>
<p>按住 <code>Alt</code> + <code>Shift</code> 键，再按上/下/左/右方向键选择：</p>
<p><img src="/images/v2-811661d856694a4fbd8b7b7fa1ece022_b.gif" alt=""></p>
<p>使用多个光标同时编辑。按住 <code>Ctrl</code> + <code>Alt</code> 键，点击或选择要插入或编辑的位置：</p>
<p><img src="/images/v2-8e2b8ed3bac36dc15e478151323d6e2c_b.gif" alt=""></p>
<p>匹配相同单词并编辑。先选择要编辑的单词或字符，再按一下 <code>Alt</code> + <code>Shift</code> + <code>;</code>，会自动匹配并选中所有相同的单词，然后开始编辑：</p>
<p><img src="/images/v2-805ebc6c9f65c554edc48ca05f059194_b.gif" alt=""></p>
<p>你也可以使用 <code>Alt</code> + <code>Shift</code> + <code>.</code> 只匹配选择下一个相同的单词。</p>
<h2 id="使用剪贴板历史粘贴"><a href="#使用剪贴板历史粘贴" class="headerlink" title="使用剪贴板历史粘贴"></a><strong>使用剪贴板历史粘贴</strong></h2><p>复制粘贴是写代码很常见的操作。我们在 Ctrl + V 时默认是粘贴你最后一次复制的内容，但有时你想使用上一次复制的内容，你可能会重新再复制一下。剪贴板一次只能包含一个内容。Visual Studio 附带了一个剪贴板历史记录，默认它包含你复制到剪贴板的最后 20 项记录。</p>
<p>通过使用 <code>Ctrl</code> + <code>Shift</code> + <code>V</code>，可以打开剪贴板的历史记录：</p>
<p><img src="/images/v2-0f074a9ddbafd34ddd4f3ee0b9b709c2_b.gif" alt=""></p>
<p>你可以将多个内容复制到剪贴板，并在稍后依次粘贴到相应的位置。</p>
<h2 id="整行上下移动"><a href="#整行上下移动" class="headerlink" title="整行上下移动"></a><strong>整行上下移动</strong></h2><p>有时候我们需要调整一下代码行的位置，比如将代码行上移或下移几行。可以按住 <code>Alt</code>，然后使用上下方向键移动整行代码：</p>
<p><img src="/images/v2-6fab67588014ad73493231a57299e8b6_b.gif" alt=""></p>
<h2 id="直接拖动引用项目"><a href="#直接拖动引用项目" class="headerlink" title="直接拖动引用项目"></a><strong>直接拖动引用项目</strong></h2><p>在 VS 中的一个项目中引用另一个项目最方便的方法是直接把要引用的项目拖到该项目。</p>
<p><img src="/images/v2-50328bb28a2212166ff3ff5f75d19a4d_b.gif" alt=""></p>
<h2 id="设置-git-pull-快捷键"><a href="#设置-git-pull-快捷键" class="headerlink" title="设置 git pull 快捷键"></a><strong>设置 git pull 快捷键</strong></h2><p>最常用的 Git 操作就是 Pull 了，平时大家都是在 Team Explorer 窗口依次点击 Sync -&gt; Pull 来操作。但用快捷键更方便，可以在 Tools -&gt; Options -&gt; Keyboard 中为 Git Pull 设置一个快捷键，比如设置为 <code>CTRL + SHIFT + P</code>。</p>
<p><img src="/images/v2-d0df521d90547de80855dea57a8f4870_720w.jpg" alt=""></p>
<h2 id="打开命令行窗口"><a href="#打开命令行窗口" class="headerlink" title="打开命令行窗口"></a><strong>打开命令行窗口</strong></h2><p>我经常需要在项目的根目录打开命令行窗口执行一些命令，比如 <code>dotnet ef</code> 相关的命令。在 VS 2019 之前，每次要打开命令行窗口并定位到项目的根目录是相当的麻烦。好在 VS 2019 终于内置了命令行窗口，通过快捷键 <code>Ctrl + `</code> 打开，或者点击 View -&gt; Teminal 打开。打开后默认定位到项目的根目录，还可以创建多个 Tab。</p>
<p><img src="/images/v2-88d2d64b2eb7aaf514e3635fef2a28b3_720w.jpg" alt=""></p>
<h2 id="设置私有字段使用下划线前缀"><a href="#设置私有字段使用下划线前缀" class="headerlink" title="设置私有字段使用下划线前缀"></a><strong>设置私有字段使用下划线前缀</strong></h2><p>默认情况下，VS 智能补全对类的私有字段使用的是 camelCase 命名风格，但有很多人更习惯使用 _camelCase 风格对私有字段命名，类的私有字段前面加 <code>_</code> 前缀有助于和本地变量进行区分。我们可以通过设置来改变默认的 camelCase 命名行为，具体设置步骤如下。</p>
<p>依次点击：Tools -&gt; Options -&gt; Text Editor -&gt; C# -&gt; Code Style -&gt; Naming -&gt; Manage naming styles。</p>
<p><img src="/images/v2-0fdf49a6380dedbc8f0503da653e46c7_720w.jpg" alt=""></p>
<p>上面的添加 Naming Style 步骤（第 4 步）很重要，为了让你们看清楚些，请参照如下单独放大的截图：</p>
<p><img src="/images/v2-d92ee4233427f9d3931f6ec0570adaf6_720w.jpg" alt=""></p>
<p>好了，来试试效果：</p>
<p><img src="/images/v2-85082722f96925a34448772007fdc4d8_b.gif" alt=""></p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a><strong>其它</strong></h2><p>本文只罗列了几个很多人都不知道的 VS 实用技巧，当然还有很多大多数人都知道的技巧，比如 Ctrl + D 复制当前行、Ctrl + X 剪切/删除当前行、Shift + Enter 新启一行等等，在这里就不一一罗列了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.bfsdfs.com/2020/09/27/%E3%80%90CSharp%E3%80%91%E6%9E%9A%E4%B8%BE%E9%AB%98%E7%BA%A7%E6%88%98%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="Mr.Guan">
      <meta itemprop="description" content="一份耕耘，一份收获">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="深度优先">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/27/%E3%80%90CSharp%E3%80%91%E6%9E%9A%E4%B8%BE%E9%AB%98%E7%BA%A7%E6%88%98%E6%9C%AF/" class="post-title-link" itemprop="url">【CSharp】枚举高级战术</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-27 15:50:57" itemprop="dateCreated datePublished" datetime="2020-09-27T15:50:57+08:00">2020-09-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%B7%AF%E4%B8%8A/" itemprop="url" rel="index"><span itemprop="name">编程路上</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/willick/p/csharp-enum-superior-tactics.html#!comments">https://www.cnblogs.com/willick/p/csharp-enum-superior-tactics.html#!comments</a></p>
</blockquote>
<p>文章开头先给大家出一道面试题：</p>
<blockquote>
<p>在设计某小型项目的数据库（假设用的是 MySQL）时，如果给用户表（User）添加一个字段（Roles）用来存储用户的角色，你会给这个字段设置什么类型？提示：要考虑到角色在后端开发时需要用枚举表示，且一个用户可能会拥有多个角色。</p>
</blockquote>
<p>映入你脑海的第一个答案可能是：varchar 类型，用分隔符的方式来存储多个角色，比如用 <code>1|2|3</code> 或  <code>1,2,3</code> 来表示用户拥有多个角色。当然如果角色数量可能超过个位数，考虑到数据库的查询方便（比如用 INSTR 或 POSITION 来判断用户是否包含某个角色），角色的值至少要从数字 10 开始。方案是可行的，可是不是太简单了，有没有更好的方案？更好的回答应是整型（int、bigint 等），优点是写 SQL 查询条件更方便，性能、空间上都优于 varchar。但整型毕竟只是一个数字，怎么表示多个角色呢？此时想到了二进制位操作的你，心中应该早有了答案。且保留你心中的答案，接着看完本文，或许你会有意外的收获，因为实际应用中可能还会遇到一连串的问题。为了更好的说明后面的问题，我们先来回顾一下枚举的基础知识。</p>
<h2 id="枚举基础"><a href="#枚举基础" class="headerlink" title="枚举基础"></a>枚举基础</h2><p>枚举类型的作用是限制其变量只能从有限的选项中取值，这些选项（枚举类型的成员）各自对应于一个数字，数字默认从 0 开始，并以此递增。例如：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> Days</span><br><span class="line">&#123;</span><br><span class="line">    Sunday, Monday, Tuesday, <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 Sunday 的值是 0，Monday 是 1，以此类推。为了一眼能看出每个成员代表的值，一般推荐显示地将成员值写出来，不要省略：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> Days</span><br><span class="line">&#123;</span><br><span class="line">    Sunday = <span class="number">0</span>, Monday = <span class="number">1</span>, Tuesday = <span class="number">2</span>, <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C# 枚举成员的类型默认是 int 类型，通过继承可以声明枚举成员为其它类型，比如：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> Days : <span class="built_in">byte</span></span><br><span class="line">&#123;</span><br><span class="line">    Monday = <span class="number">1</span>,</span><br><span class="line">    Tuesday = <span class="number">2</span>,</span><br><span class="line">    Wednesday = <span class="number">3</span>,</span><br><span class="line">    Thursday = <span class="number">4</span>,</span><br><span class="line">    Friday = <span class="number">5</span>,</span><br><span class="line">    Saturday = <span class="number">6</span>,</span><br><span class="line">    Sunday = <span class="number">7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举类型一定是继承自 byte、sbyte、short、ushort、int、uint、long 和 ulong 中的一种，不能是其它类型。下面是几个枚举的常见用法（以上面的 Days 枚举为例）：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 枚举转字符串</span></span><br><span class="line"><span class="built_in">string</span> foo = Days.Saturday.ToString(); <span class="comment">// &quot;Saturday&quot;</span></span><br><span class="line"><span class="built_in">string</span> foo = Enum.GetName(<span class="keyword">typeof</span>(Days), <span class="number">6</span>); <span class="comment">// &quot;Saturday&quot;</span></span><br><span class="line"><span class="comment">// 字符串转枚举</span></span><br><span class="line">Enum.TryParse(<span class="string">&quot;Tuesday&quot;</span>, <span class="keyword">out</span> Days bar); <span class="comment">// true, bar = Days.Tuesday</span></span><br><span class="line">(Days)Enum.Parse(<span class="keyword">typeof</span>(Days), <span class="string">&quot;Tuesday&quot;</span>); <span class="comment">// Days.Tuesday</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举转数字</span></span><br><span class="line"><span class="built_in">byte</span> foo = (<span class="built_in">byte</span>)Days.Monday; <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 数字转枚举</span></span><br><span class="line">Days foo = (Days)<span class="number">2</span>; <span class="comment">// Days.Tuesday</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取枚举所属的数字类型</span></span><br><span class="line">Type foo = Enum.GetUnderlyingType(<span class="keyword">typeof</span>(Days))); <span class="comment">// System.Byte</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有的枚举成员</span></span><br><span class="line">Array foo = Enum.GetValues(<span class="keyword">typeof</span>(MyEnum);</span><br><span class="line"><span class="comment">// 获取所有枚举成员的字段名</span></span><br><span class="line"><span class="built_in">string</span>[] foo = Enum.GetNames(<span class="keyword">typeof</span>(Days));</span><br></pre></td></tr></table></figure>

<p>另外，值得注意的是，枚举可能会得到非预期的值（值没有对应的成员）。比如：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Days d = (Days)<span class="number">21</span>; <span class="comment">// 不会报错</span></span><br><span class="line">Enum.IsDefined(<span class="keyword">typeof</span>(Days), d); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>即使枚举没有值为 0 的成员，它的默认值永远都是 0。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> z = <span class="literal">default</span>(Days); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>枚举可以通过 Description、Display 等特性来为成员添加有用的辅助信息，比如：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> ApiStatus</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Description(<span class="string">&quot;成功&quot;</span>)</span>]</span><br><span class="line">    OK = <span class="number">0</span>,</span><br><span class="line">    [<span class="meta">Description(<span class="string">&quot;资源未找到&quot;</span>)</span>]</span><br><span class="line">    NotFound = <span class="number">2</span>,</span><br><span class="line">    [<span class="meta">Description(<span class="string">&quot;拒绝访问&quot;</span>)</span>]</span><br><span class="line">    AccessDenied = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">EnumExtensions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">GetDescription</span>(<span class="params"><span class="keyword">this</span> Enum val</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> field = val.GetType().GetField(val.ToString());</span><br><span class="line">        <span class="keyword">var</span> customAttribute = Attribute.GetCustomAttribute(field, <span class="keyword">typeof</span>(DescriptionAttribute));</span><br><span class="line">        <span class="keyword">if</span> (customAttribute == <span class="literal">null</span>) &#123; <span class="keyword">return</span> val.ToString(); &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="keyword">return</span> ((DescriptionAttribute)customAttribute).Description; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(ApiStatus.Ok.GetDescription()); <span class="comment">// &quot;成功&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这些我认为已经包含了大部分我们日常用到的枚举知识了。下面我们继续回到文章开头说的用户角色存储问题。</p>
<h2 id="用户角色存储问题"><a href="#用户角色存储问题" class="headerlink" title="用户角色存储问题"></a>用户角色存储问题</h2><p>我们先定义一个枚举类型来表示两种用户角色：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> Roles</span><br><span class="line">&#123;</span><br><span class="line">    Admin = <span class="number">1</span>,</span><br><span class="line">    Member = <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，如果某个用户同时拥有 Admin 和 Member 两种角色，那么 User 表的 Roles 字段就应该存 3。那问题来了，此时若查询所有拥有 Admin 角色的用户的 SQL 该怎么写呢？对于有基础的程序员来说，这个问题很简单，只要用位操作符逻辑与（‘&amp;’）来查询即可。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `<span class="keyword">User</span>` <span class="keyword">WHERE</span> `Roles` <span class="operator">&amp;</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>同理，查询同时拥有这两种角色的用户，SQL 语句应该这么写：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `<span class="keyword">User</span>` <span class="keyword">WHERE</span> `Roles` <span class="operator">&amp;</span> <span class="number">3</span> <span class="operator">=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>对这条 SQL 语句用 C# 来实现查询是这样的（为了简单，这里使用了 Dapper）：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">User</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Roles Roles &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">connection.Query&lt;User&gt;(</span><br><span class="line">    <span class="string">&quot;SELECT * FROM `User` WHERE `Roles` &amp; @roles = @roles;&quot;</span>,</span><br><span class="line">    <span class="keyword">new</span> &#123; roles = Roles.Admin | Roles.Member &#125;);</span><br></pre></td></tr></table></figure>

<p>对应的，在 C# 中要判断用户是否拥有某个角色，可以这么判断：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一</span></span><br><span class="line"><span class="keyword">if</span> ((user.Roles &amp; Roles.Admin) == Roles.Admin)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 做管理员可以做的事情</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line"><span class="keyword">if</span> (user.Roles.HasFlag(Roles.Admin))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 做管理员可以做的事情</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同理，在 C# 中你可以对枚举进行任意位逻辑运算，比如要把角色从某个枚举变量中移除：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = Roles.Admin | Roles.Member;</span><br><span class="line"><span class="keyword">var</span> bar = foo &amp; ~Roles.Admin;</span><br></pre></td></tr></table></figure>

<p>这就解决了文章前面提到的用整型来存储多角色的问题，不论数据库还是 C# 语言，操作上都是可行的，而且也很方便灵活。</p>
<h2 id="枚举的-Flags-特性"><a href="#枚举的-Flags-特性" class="headerlink" title="枚举的 Flags 特性"></a>枚举的 Flags 特性</h2><p>下面我们提供一个通过角色来查询用户的方法，并演示如何调用，如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IEnumerable</span>&lt;<span class="title">User</span>&gt; <span class="title">GetUsersInRoles</span>(<span class="params">Roles roles</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    _logger.LogDebug(roles.ToString());</span><br><span class="line">    _connection.Query&lt;User&gt;(</span><br><span class="line">        <span class="string">&quot;SELECT * FROM `User` WHERE `Roles` &amp; @roles = @roles;&quot;</span>,</span><br><span class="line">        <span class="keyword">new</span> &#123; roles &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">_repository.GetUsersInRoles(Roles.Admin | Roles.Member);</span><br></pre></td></tr></table></figure>

<p><code>Roles.Admin | Roles.Member</code> 的值是 3，由于 Roles 枚举类型中并没有定义一个值为 3 的字段，所以在方法内 roles 参数显示的是 3。3 这个信息对于我们调试或打印日志很不友好。在方法内，我们并不知道这个 3 代表的是什么。为了解决这个问题，C# 枚举有个很有用的特性：FlagsAtrribute。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Flags</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> Roles</span><br><span class="line">&#123;</span><br><span class="line">    Admin = <span class="number">1</span>,</span><br><span class="line">    Member = <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加上这个 Flags 特性后，我们再来调试 <code>GetUsersInRoles(Roles roles)</code> 方法时，roles 参数的值就会显示为 <code>Admin|Member</code> 了。简单来说，加不加 Flags 的区别是：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> roles = Roles.Admin | Roles.Member;</span><br><span class="line">Console.WriteLing(roles.ToString()); <span class="comment">// &quot;3&quot;，没有 Flags 特性</span></span><br><span class="line">Console.WriteLing(roles.ToString()); <span class="comment">// &quot;Admin, Member&quot;，有 Flags 特性</span></span><br></pre></td></tr></table></figure>

<p>给枚举加上 Flags 特性，我觉得应当视为 C# 编程的一种最佳实践，在定义枚举时尽量加上 Flags 特性。</p>
<h2 id="解决枚举值冲突：2-的幂"><a href="#解决枚举值冲突：2-的幂" class="headerlink" title="解决枚举值冲突：2 的幂"></a>解决枚举值冲突：2 的幂</h2><p>到这，枚举类型 Roles 一切看上去没什么问题，但如果现在要增加一个角色：Mananger，会发生什么情况？按照数字值递增的规则，Manager 的值应当设为 3。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Flags</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> Roles</span><br><span class="line">&#123;</span><br><span class="line">    Admin = <span class="number">1</span>,</span><br><span class="line">    Member = <span class="number">2</span>,</span><br><span class="line">    Manager = <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>能不能把 Manager 的值设为 3？显然不能，因为 Admin 和 Member 进行位的或逻辑运算（即：Admin | Member） 的值也是 3，表示同时拥有这两种角色，这和 Manager 冲突了。那怎样设值才能避免冲突呢？既然是二进制逻辑运算“或”会和成员值产生冲突，那就利用逻辑运算或的规律来解决。我们知道“或”运算的逻辑是两边只要出现一个 1 结果就会 1，比如 1|1、1|0 结果都是 1，只有 0|0 的情况结果才是 0。那么我们就要避免任意两个值在相同的位置上出现 1。根据二进制满 2 进 1 的特点，只要保证枚举的各项值都是 2 的幂即可。比如：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>:  <span class="number">00000001</span></span><br><span class="line"><span class="number">2</span>:  <span class="number">00000010</span></span><br><span class="line"><span class="number">4</span>:  <span class="number">00000100</span></span><br><span class="line"><span class="number">8</span>:  <span class="number">00001000</span></span><br></pre></td></tr></table></figure>

<p>再往后增加的话就是 16、32、64…，其中各值不论怎么相加都不会和成员的任一值冲突。这样问题就解决了，所以我们要这样定义 Roles 枚举的值：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Flags</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> Roles</span><br><span class="line">&#123;</span><br><span class="line">    Admin = <span class="number">1</span>,</span><br><span class="line">    Member = <span class="number">2</span>,</span><br><span class="line">    Manager = <span class="number">4</span>,</span><br><span class="line">    Operator = <span class="number">8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过在定义值的时候要在心中小小计算一下，如果你想懒一点，可以用下面这种“位移”的方法来定义：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">Flags</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> Roles</span><br><span class="line">&#123;</span><br><span class="line">    Admin    = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">    Member   = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">    Manager  = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">    Operator = <span class="number">1</span> &lt;&lt; <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一直往下递增编值即可，阅读体验好，也不容易编错。两种方式是等效的，常量位移的计算是在编译的时候进行的，所以相比不会有额外的开销。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文通过一道小小的面试题引发一连串对枚举的思考。在小型系统中，把用户角色直接存储在用户表是很常见的做法，此时把角色字段设为整型（比如 int）是比较好的设计方案。但与此同时，也要考虑到一些最佳实践，比如使用 Flags 特性来帮助更好的调试和日志输出。也要考虑到实际开发中的各种潜在问题，比如多个枚举值进行或（‘|’）运算与成员值发生冲突的问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.bfsdfs.com/2020/09/23/%E3%80%90MySql%E3%80%91%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E5%8F%8A%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="Mr.Guan">
      <meta itemprop="description" content="一份耕耘，一份收获">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="深度优先">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/23/%E3%80%90MySql%E3%80%91%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E5%8F%8A%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">【MySql】索引结构及查询优化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-23 10:09:28" itemprop="dateCreated datePublished" datetime="2020-09-23T10:09:28+08:00">2020-09-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>23k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>21 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/itwild/p/13703259.html">https://www.cnblogs.com/itwild/p/13703259.html</a></p>
</blockquote>
<p>(同时再次强调，这几篇关于MySQL的探究都是基于<code>5.7</code>版本，相关总结与结论<code>不一定适用</code>于其他版本)</p>
<p>MySQL官方文档中(<code>https://dev.mysql.com/doc/refman/5.7/en/optimization-indexes.html</code>)有这样一段描述：</p>
<blockquote>
<p>The best way to improve the performance of SELECT operations is to create indexes on one or more of the columns that are tested in the query. But unnecessary indexes waste space and waste time for MySQL to determine which indexes to use. Indexes also add to the cost of inserts, updates, and deletes because each index must be updated. You must find the right balance to achieve fast queries using the optimal set of indexes.</p>
</blockquote>
<p>就是说提高查询性能最直接有效的方法就是建立索引，但是不必要的索引会浪费空间，同时也增加了额外的时间成本去判断应该走哪个索引，此外，索引还会增加插入、更新、删除数据的成本，因为做这些操作的同时还要去维护(更新)索引树。因此，应该学会使用最佳索引集来优化查询。</p>
<h2 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h2><p>参考：</p>
<ol>
<li><p>《MySQL索引背后的数据结构及算法原理》<code>http://blog.codinglabs.org/articles/theory-of-mysql-index.html</code></p>
</li>
<li><p>《Mysql BTree和B+Tree详解》<code>https://www.cnblogs.com/Transkai/p/11595405.html</code></p>
</li>
<li><p>《为什么MySQL使用B+树》<code>https://draveness.me/whys-the-design-mysql-b-plus-tree/</code></p>
</li>
<li><p>《浅入浅出MySQL和InnoDB》<code>https://draveness.me/mysql-innodb/</code></p>
</li>
<li><p>《漫画：什么是B树？》<code>https://mp.weixin.qq.com/s/rDCEFzoKHIjyHfI_bsz5Rw</code></p>
</li>
</ol>
<h3 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h3><p>在MySQL中，索引(<code>Index</code>)是帮助高效获取数据的数据结构。这种数据结构MySQL中最常用的就是B+树(<code>B+Tree</code>)。</p>
<blockquote>
<p>Indexes are used to find rows with specific column values quickly. Without an index, MySQL must begin with the first row and then read through the entire table to find the relevant rows.</p>
</blockquote>
<p>就好比给你一本书和一篇文章标题，如果没有目录，让你找此标题对应的文章，可能需要从第一页翻到最后一页；如果有目录大纲，你可能只需要在目录页寻找此标题，然后迅速定位文章。</p>
<p>这里我们可以把<code>书(book)</code>看成是MySQL中的<code>table</code>，把<code>文章(article)</code>看成是<code>table</code>中的一行记录，即<code>row</code>，<code>文章标题(title)</code>看成<code>row</code>中的一列<code>column</code>，<code>目录</code>自然就是对<code>title</code>列建立的索引<code>index</code>了，这样<code>根据文章标题从书中检索文章</code>就对应sql语句<code>select * from book where title = ?</code>，相应的，书中每增加一篇文章(即<code>insert into book (title, ...) values (&#39;华山论剑&#39;, ...)</code>)，都需要维护一下<code>目录</code>，这样才能从目录中找到新增的文章<code>华山论剑</code>，这一操作对应的是MySQL中每插入(<code>insert</code>)一条记录需要维护<code>title</code>列的索引树(<code>B+Tree</code>)。</p>
<h3 id="为什么使用B-Tree"><a href="#为什么使用B-Tree" class="headerlink" title="为什么使用B+Tree"></a>为什么使用B+Tree</h3><p>首先需要澄清的一点是，MySQL跟B+树没有直接的关系，真正与B+树有关系的是MySQL的默认存储引擎<code>InnoDB</code>，MySQL中存储引擎的主要作用是<code>负责数据的存储和提取</code>，除了<code>InnoDB</code>之外，MySQL中也支持比如<code>MyISAM</code>等其他存储引擎(详情见<code>https://dev.mysql.com/doc/refman/5.7/en/storage-engine-setting.html</code>)作为表的底层存储引擎。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">`mysql&gt; show engines;</span><br><span class="line">+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span><br><span class="line">| Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |</span><br><span class="line">+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+</span><br><span class="line">| MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |</span><br><span class="line">| CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |</span><br><span class="line">| PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |</span><br><span class="line">| BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears) | NO           | NO   | NO         |</span><br><span class="line">| InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |</span><br><span class="line">| MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         |</span><br><span class="line">| ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |</span><br><span class="line">| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         |</span><br><span class="line">| FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       |</span><br><span class="line">+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+`</span><br></pre></td></tr></table></figure>

<p>提到索引，我们可能会立马想到下面几种数据结构来实现。</p>
<p>(1) 哈希表<br>哈希虽然能够提供 <code>O(1)</code>的单数据行的查询性能，但是对于<code>范围查询</code>和<code>排序</code>却无法很好支持，需全表扫描。</p>
<p>(2) 红黑树<br>红黑树( <code>Red Black Tree</code>)是一种自平衡二叉查找树，在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。</p>
<p>一般来说，索引本身也很大，往往不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗远远高于内存，所以评价一个数据结构作为索引的优劣最重要的指标就是查找过程中磁盘I/O次数。换句话说，<code>索引的结构组织要尽量减少查找过程中磁盘I/O的次数。</code></p>
<p>在这里，磁盘I/O的次数取决于树的高度，所以，在数据量较大时，<code>红黑树会因树的高度较大而造成磁盘IO较多</code>，从而影响查询效率。</p>
<p>(3) B-Tree<br>B树中的B代表平衡( <code>Balance</code>)，而不是二叉(<code>Binary</code>)，B树是从平衡二叉树演化而来的。</p>
<p>为了降低树的高度(也就是减少磁盘I/O次数)，把原来<code>瘦高</code>的树结构变得<code>矮胖</code>，B树会在<code>每个节点存储多个元素</code>(红黑树每个节点只会存储一个元素)，并且节点中的元素从左到右递增排列。如下图所示：</p>
<p><a href="/images/1546632-20200830195348368-1304078258.png"><img src="/images/1546632-20200830195348368-1304078258.png" alt="B-Tree结构图"></a></p>
<p><code>B-Tree</code>在查询的时候比较次数其实不比二叉查找树少，但在内存中的大小比较、二分查找的耗时相比磁盘IO耗时几乎可以忽略。 <code>B-Tree大大降低了树的高度</code>，所以也就极大地提升了查找性能。</p>
<p>(4) B+Tree<br><code>B+Tree</code>是在<code>B-Tree</code>基础上进一步优化，使其更适合实现存储索引结构。InnoDB存储引擎就是用<code>B+Tree</code>实现其索引结构。</p>
<p><code>B-Tree</code>结构图中可以看到每个节点中不仅包含数据的<code>key</code>值，还有<code>data</code>值。而每一个节点的存储空间是有限的，如果<code>data</code>值较大时将会导致每个节点能存储的<code>key</code>的数量很小，这样会导致B-Tree的高度变大，增加了查询时的磁盘I/O次数，进而影响查询性能。在<code>B+Tree</code>中，所有<code>data</code>值都是按照键值大小顺序存放在同一层的叶子节点上，而<code>非叶子节点上只存储key值信息</code>，这样可以增大每个非叶子节点存储的<code>key</code>值数量，降低B+Tree的高度，提高效率。</p>
<p><a href="/images/1546632-20200830201413134-394816073.png"><img src="/images/1546632-20200830201413134-394816073.png" alt="B+Tree结构图"></a></p>
<p><strong>这里补充一点相关知识</strong> 在计算机中，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的<code>局部性原理</code>：</p>
<blockquote>
<p>当一个数据被用到时，其附近的数据也通常会马上被使用。</p>
</blockquote>
<p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。预读的长度一般为页(<code>page</code>)的整数倍。</p>
<p><code>页</code>是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页(许多操作系统的页默认大小为<code>4KB</code>)，主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时操作系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。(如下命令可以查看操作系统的默认页大小)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`$ getconf PAGE_SIZE</span><br><span class="line">4096`</span><br></pre></td></tr></table></figure>

<p>数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为操作系统的页大小的整数倍，这样每个节点只需要一次I/O就可以完全载入。</p>
<p><code>InnoDB</code>存储引擎中也有页(<code>Page</code>)的概念，页是其磁盘管理的最小单位。InnoDB存储引擎中默认每个页的大小为16KB。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">`mysql&gt; show variables like &#x27;innodb_page_size&#x27;;</span><br><span class="line">+------------------+-------+</span><br><span class="line">| Variable_name    | Value |</span><br><span class="line">+------------------+-------+</span><br><span class="line">| innodb_page_size | 16384 |</span><br><span class="line">+------------------+-------+</span><br><span class="line">1 row in set (0.01 sec)`</span><br></pre></td></tr></table></figure>

<p>一般表的主键类型为<code>INT</code>（占4个字节）或<code>BIGINT</code>（占8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储<code>16KB/(8B+8B)=1K</code>个键值（因为是估值，为方便计算，这里的K取值为<code>10^3</code>）。也就是说一个深度为3的B+Tree索引可以维护<code>10^3 * 10^3 * 10^3 = 10亿</code>条记录。</p>
<p><code>B+Tree</code>的高度一般都在2到4层。mysql的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1到3次磁盘I/O操作。</p>
<p>随机I/O对于MySQL的查询性能影响会非常大，而顺序读取磁盘中的数据会很快，由此我们也应该尽量减少随机I/O的次数，这样才能提高性能。在<code>B-Tree</code>中由于所有的节点都可能包含目标数据，我们总是要从根节点向下遍历子树查找满足条件的数据行，这会带来大量的随机I/O，而<code>B+Tree</code>所有的数据行都存储在叶子节点中，而这些叶子节点通过<code>双向链表</code>依次按顺序连接，当我们在B+树遍历数据(比如说<code>范围查询</code>)时可以直接在多个叶子节点之间进行跳转，保证<code>顺序</code>、<code>倒序</code>遍历的性能。</p>
<p>另外，对以上提到的数据结构不熟悉的朋友，这里推荐一个在线数据结构可视化演示工具，有助于快速理解这些数据结构的机制：<code>https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</code></p>
<h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p>上面也有提及，在MySQL中，索引属于存储引擎级别的概念。不同存储引擎对索引的实现方式是不同的，这里主要看下<code>MyISAM</code>和<code>InnoDB</code>两种存储引擎的索引实现方式。</p>
<h4 id="MyISAM索引实现"><a href="#MyISAM索引实现" class="headerlink" title="MyISAM索引实现"></a>MyISAM索引实现</h4><p><code>MyISAM</code>引擎使用<code>B+Tree</code>作为索引结构时叶子节点的<code>data</code>域存放的是数据记录的地址。如下图所示：</p>
<p><a href="/images/1546632-20200919221036646-2109444544.png"><img src="/images/1546632-20200919221036646-2109444544.png" alt="MyISAM主键索引原理图"></a></p>
<p>由上图可以看出：MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址，因此MyISAM的索引方式也叫做<code>非聚集</code>的，之所以这么称呼是为了与InnoDB的<code>聚集索引</code>区分。</p>
<h4 id="InnoDB索引实现"><a href="#InnoDB索引实现" class="headerlink" title="InnoDB索引实现"></a>InnoDB索引实现</h4><p><code>InnoDB</code>的<code>主键索引</code>也使用<code>B+Tree</code>作为索引结构时的实现方式却与MyISAM截然不同。<code>InnoDB的数据文件本身就是索引文件</code>。在InnoDB中，表数据文件本身就是按<code>B+Tree</code>组织的一个索引结构，这棵树的叶子节点<code>data</code>域保存了完整的数据记录，这个索引的<code>key</code>是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p>
<p><a href="/images/1546632-20200919222451055-995072120.png"><img src="/images/1546632-20200919222451055-995072120.png" alt="InnoDB主键索引原理图"></a></p>
<p><code>InnoDB</code>存储引擎中的主键索引(<code>primary key</code>)又叫做聚集索引(<code>clustered index</code>)。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。(详情见官方文档：<code>https://dev.mysql.com/doc/refman/5.7/en/innodb-index-types.html</code>)</p>
<p>聚集索引这种实现方式使得按主键搜索十分高效，直接能查出整行数据。</p>
<p>在InnoDB中，用非单调递增的字段作为主键不是个好主意，因为InnoDB数据文件本身是一棵<code>B+Tree</code>，非单增的主键会造成在插入新记录时数据文件为了<code>维持B+Tree的特性</code>而频繁的分裂调整，十分低效，因而使用<code>递增</code>字段作为主键则是一个很好的选择。</p>
<h3 id="非主键索引"><a href="#非主键索引" class="headerlink" title="非主键索引"></a>非主键索引</h3><h4 id="MyISAM索引实现-1"><a href="#MyISAM索引实现-1" class="headerlink" title="MyISAM索引实现"></a>MyISAM索引实现</h4><p>MyISAM中，主键索引和非主键索引（<code>Secondary key</code>，也有人叫做<code>辅助索引</code>）在结构上没有任何区别，只是主键索引要求key是唯一的，而辅助索引的key可以重复。这里不再多加叙述。</p>
<h4 id="InnoDB索引实现-1"><a href="#InnoDB索引实现-1" class="headerlink" title="InnoDB索引实现"></a>InnoDB索引实现</h4><p>InnoDB的非主键索引<code>data</code>域存储相应记录<code>主键的值</code>。换句话说，InnoDB的所有非主键索引都引用主键的值作为data域。如下图所示：</p>
<p><a href="/images/1546632-20200919225813936-1490118290.png"><img src="/images/1546632-20200919225813936-1490118290.png" alt="InnoDB非主键索引原理图"></a></p>
<p>由上图可知：使用非主键索引搜索时需要检索两遍索引，首先检索非主键索引获得主键(<code>primary key</code>)，然后用主键到<code>主键索引树</code>中检索获得完整记录。</p>
<p>那么为什么非主键索引结构叶子节点存储的是主键值，而不像主键索引那样直接存储完整的一行数据，这样就能避免回表二次检索？显然，这样做一方面节省了大量的存储空间，另一方面多份冗余数据，更新数据的效率肯定低下，另外保证数据的一致性是个麻烦事。</p>
<p>到了这里，也很容易明白为什么<code>不建议使用过长的字段作为主键</code>，因为所有的非主键索引都引用主键值，过长的主键值会让非主键索引变得过大。</p>
<h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>官方文档：<code>https://dev.mysql.com/doc/refman/5.7/en/multiple-column-indexes.html</code></p>
<p>比如<code>INDEX idx_book_id_hero_name (book_id, hero_name) USING BTREE</code>，即对<code>book_id, hero_name</code>两列建立了一个联合索引。</p>
<blockquote>
<p>A multiple-column index can be considered a sorted array, the rows of which contain values that are created by concatenating the values of the indexed columns.</p>
</blockquote>
<p>联合索引是多列按照次序一列一列比较大小，拿<code>idx_book_id_hero_name</code>这个联合索引来说，先比较<code>book_id</code>，book_id小的排在左边，book_id大的排在右边，book_id相同时再比较<code>hero_name</code>。如下图所示：</p>
<p><a href="/images/1546632-20200920111026527-1672463564.png"><img src="/images/1546632-20200920111026527-1672463564.png" alt="InnoDB联合索引原理图"></a></p>
<p>了解了联合索引的结构，就能引入<code>最左前缀法则</code>：</p>
<blockquote>
<p>If the table has a multiple-column index, any leftmost prefix of the index can be used by the optimizer to look up rows. For example, if you have a three-column index on (col1, col2, col3), you have indexed search capabilities on (col1), (col1, col2), and (col1, col2, col3).</p>
</blockquote>
<p>就是说联合索引中的多列是按照列的次序排列的，如果查询的时候不能满足列的次序，比如说where条件中缺少<code>col1 = ?</code>，直接就是<code>col2 = ? and col3 = ?</code>，那么就走不了联合索引，从上面联合索引的结构图应该能明显看出，只有<code>col2</code>列无法通过索引树检索符合条件的数据。</p>
<p>根据最左前缀法则，我们知道对<code>INDEX idx_book_id_hero_name (book_id, hero_name)</code>来说，<code>where book_id = ? and hero_name = ?</code>的查询来说，肯定可以走索引，但是如果是<code>where hero_name = ? and book_id = ?</code>呢，表面上看起来不符合最左前缀法则啊，但MySQL优化器会根据已有的索引，调整查询条件中这两列的顺序，让它符合最左前缀法则，走索引，这里也就回答了上篇《一文学会MySQL的explain工具》中为什么用<code>show warnings</code>命令查看时，<code>where</code>中的两个过滤条件<code>hero_name</code>、<code>book_id</code>先后顺序被调换了。</p>
<p>至于对联合索引中的列进行范围查询等各种情况，都可以先想联合索引的结构是如何创建出来的，然后看过滤条件是否满足最左前缀法则。比如说范围查询时，范围列可以用到索引（必须是最左前缀），但是范围列后面的列无法用到索引。同时，索引最多用于一个范围列，因此如果查询条件中有两个范围列则无法全用到索引。</p>
<h2 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h2><h3 id="主键的选择"><a href="#主键的选择" class="headerlink" title="主键的选择"></a>主键的选择</h3><p>在使用<code>InnoDB</code>存储引擎时，如果没有特别的需要，尽量使用一个与业务无关的<code>递增字段</code>作为主键，主键字段不宜过长。原因上面在讲索引结构时已提过。比如说常用雪花算法生成64bit大小的整数(占8个字节，用<code>BIGINT</code>类型)作为主键就是一个不错的选择。</p>
<h3 id="索引的选择"><a href="#索引的选择" class="headerlink" title="索引的选择"></a>索引的选择</h3><p>(1) 表记录比较少的时候，比如说只有几百条记录的表，对一些列建立索引的意义可能并不大，所以表记录不大时酌情考虑索引。但是业务上具有<code>唯一特性</code>的字段，即使是多个字段的组合，也建议使用唯一索引(<code>UNIQUE KEY</code>)。</p>
<p>(2) 当索引的选择性非常低时，索引的意义可能也不大。所谓索引的选择性(<code>Selectivity</code>)，是指不重复的索引值(也叫基数<code>Cardinality</code>)与表记录数的比值，即<code>count(distinct 列名)/count(*)</code>，常见的场景就是有一列<code>status</code>标识数据行的状态，可能<code>status</code>非0即1，总数据100万行有50万行<code>status</code>为0，50万行<code>status</code>为1，那么是否有必要对这一列单独建立索引呢？</p>
<blockquote>
<p>An index is best used when you need to select a small number of rows in comparison to the total rows.</p>
</blockquote>
<p>这句话我摘自stackoverflow上《MySQL: low selectivity columns = how to index?》下面一个人的回答。(详情见：<code>https://stackoverflow.com/questions/2386852/mysql-low-cardinality-selectivity-columns-how-to-index</code>)</p>
<p>对于上面说的<code>status</code>非0即1，而且这两种情况分布比较均匀的情况，索引可能并没有实际意义，实际查询时，MySQL优化器在计算全表扫描和索引树扫描代价后，可能会放弃走索引，因为先从<code>status</code>索引树中遍历出来主键值，再去主键索引树中查最终数据，代价可能比全表扫描还高。</p>
<p>但是如果对于<code>status</code>为1的数据只有1万行，其他99万行数据<code>status</code>为0的情况呢，你怎么看？欢迎有兴趣的朋友在文章下面留言讨论！</p>
<p><strong>补充</strong>: 关于MySQL如何选择走不走索引或者选择走哪个最佳索引，可以使用MySQL自带的trace工具一探究竟。具体使用见下面的官方文档。<br><code>https://dev.mysql.com/doc/internals/en/optimizer-tracing.html</code><br><code>https://dev.mysql.com/doc/refman/5.7/en/information-schema-optimizer-trace-table.html</code></p>
<p>使用方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set session optimizer_trace=&quot;enabled=on&quot;,end_markers_in_json=on;</span><br><span class="line">mysql&gt; select * from tb_hero where hero_id = 1;</span><br><span class="line">mysql&gt; SELECT * FROM information_schema.OPTIMIZER_TRACE;`</span><br></pre></td></tr></table></figure>

<p><code>注意</code>：开启trace工具会影响MySQL性能，所以只能临时分析sql使用，用完之后应当立即关闭</p>
<p><code>mysql&gt; set session optimizer_trace=&quot;enabled=off&quot;;</code></p>
<p>(3) 在<code>varchar</code>类型字段上建立索引时，建议指定<code>索引长度</code>，有些时候可能没必要对全字段建立索引，根据实际文本区分度决定索引长度即可【说明：索引的长度与区分度是一对矛盾体，<code>一般对字符串类型数据，长度为20的索引，区分度会高达90%以上</code>，可以使用<code>count(distinct left(列名, 索引长度))/count(*)</code>来确定区分度】。</p>
<p>这种指定索引长度的索引叫做<code>前缀索引</code>(详情见<code>https://dev.mysql.com/doc/refman/5.7/en/column-indexes.html#column-indexes-prefix</code>)。</p>
<blockquote>
<p>With col_name(N) syntax in an index specification for a string column, you can create an index that uses only the first N characters of the column. Indexing only a prefix of column values in this way can make the index file much smaller. When you index a BLOB or TEXT column, you must specify a prefix length for the index.</p>
</blockquote>
<p>前缀索引语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alter table tb_hero add index idx_hero_name_skill2 (hero_name, skill(2));`</span><br></pre></td></tr></table></figure>

<p>前缀索引兼顾索引大小和查询速度，但是其缺点是不能用于<code>group by</code>和<code>order by</code>操作，也不能用于<code>covering index</code>（即当索引本身包含查询所需全部数据时，不再访问数据文件本身）。</p>
<p>(4) 当查询语句的<code>where</code>条件或<code>group by</code>、<code>order by</code>含多列时，可根据实际情况优先考虑联合索引(<code>multiple-column index</code>)，这样可以减少单列索引(<code>single-column index)</code>的个数，有助于高效查询。</p>
<blockquote>
<p>If you specify the columns in the right order in the index definition, a single composite index can speed up several kinds of queries on the same table.</p>
</blockquote>
<p>建立联合索引时要特别注意<code>column</code>的次序，应结合上面提到的<code>最左前缀法则</code>以及实际的过滤、分组、排序需求。<code>区分度最高的建议放最左边</code>。</p>
<p>说明：</p>
<ul>
<li><p><code>order by</code>的字段可以作为联合索引的一部分，并且放在最后，避免出现<code>file_sort</code>的情况，影响查询性能。正例：<code>where a=? and b=? order by c</code>会走索引<code>idx_a_b_c</code>，但是<code>WHERE a&gt;10 order by b</code>却无法完全使用上索引<code>idx_a_b</code>，只会使用上联合索引的第一列a</p>
</li>
<li><p>存在非等号和等号混合时，在建联合索引时，应该把等号条件的列前置。如：<code>where c&gt;? and d=?</code>那么即使c的区分度更高，也应该把d放在索引的最前列，即索引<code>idx_d_c</code></p>
</li>
<li><p>如果<code>where a=? and b=?</code>，如果a列的几乎接近于唯一值，那么只需要建立单列索引<code>idx_a</code>即可</p>
</li>
</ul>
<h3 id="order-by与group-by"><a href="#order-by与group-by" class="headerlink" title="order by与group by"></a>order by与group by</h3><p>尽量在索引列上完成分组、排序，遵循索引<code>最左前缀法则</code>，如果<code>order by</code>的条件不在索引列上，就会产生<code>Using filesort</code>，降低查询性能。</p>
<h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p>MySQL分页查询大多数写法可能如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tb_hero limit offset,N;`</span><br></pre></td></tr></table></figure>

<p>MySQL并不是跳过<code>offset</code>行，而是取<code>offset+N</code>行，然后返回放弃前<code>offset</code>行，返回<code>N</code>行，那当<code>offset</code>特别大的时候，效率就非常的低下。</p>
<p>可以对超过特定阈值的页数进行SQL改写如下：</p>
<p>先快速定位需要获取的id段，然后再关联</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select a.* from tb_hero a, (select hero_id from tb_hero where 条件 limit 100000,20 ) b where a.hero_id = b.hero_id;`</span><br></pre></td></tr></table></figure>

<p>或者这种写法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select a.* from tb_hero a inner join (select hero_id from tb_hero where 条件 limit 100000,20) b on a.hero_id = b.hero_id;`</span><br></pre></td></tr></table></figure>

<h3 id="多表join"><a href="#多表join" class="headerlink" title="多表join"></a>多表join</h3><p>(1) 需要join的字段，数据类型必须绝对一致；<br>(2) 多表join时，保证被关联的字段有索引</p>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>利用覆盖索引(<code>covering index</code>)来进行查询操作，避免回表，从而增加磁盘I/O。换句话说就是，尽可能避免<code>select *</code>语句，只选择必要的列，去除无用的列。</p>
<blockquote>
<p>An index that includes all the columns retrieved by a query. Instead of using the index values as pointers to find the full table rows, the query returns values from the index structure, saving disk I/O. InnoDB can apply this optimization technique to more indexes than MyISAM can, because InnoDB secondary indexes also include the primary key columns. InnoDB cannot apply this technique for queries against tables modified by a transaction, until that transaction ends.</p>
</blockquote>
<blockquote>
<p>Any column index or composite index could act as a covering index, given the right query. Design your indexes and queries to take advantage of this optimization technique wherever possible.</p>
</blockquote>
<p>当索引本身包含查询所需全部列时，无需回表查询完整的行记录。对于<code>InnoDB</code>来说，非主键索引中包含了<code>所有的索引列</code>以及<code>主键值</code>，查询的时候尽量用这种特性避免回表操作，数据量很大时，查询性能提升很明显。</p>
<h3 id="in和exsits"><a href="#in和exsits" class="headerlink" title="in和exsits"></a>in和exsits</h3><p>原则：<code>小表驱动大表</code>，即小的数据集驱动大的数据集</p>
<p>(1) 当A表的数据集大于B表的数据集时，<code>in</code>优于<code>exists</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from A where id in (select id from B)`</span><br></pre></td></tr></table></figure>

<p>(2) 当A表的数据集小于B表的数据集时，<code>exists</code>优于<code>in</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from A where exists (select 1 from B where B.id = A.id)`</span><br></pre></td></tr></table></figure>

<h3 id="like"><a href="#like" class="headerlink" title="like"></a>like</h3><p>索引文件具有<code>B+Tree</code>最左前缀匹配特性，如果左边的值未确定，那么无法使用索引，所以应尽量避免左模糊(即<code>%xxx</code>)或者全模糊(即<code>%xxx%</code>)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">`mysql&gt; select * from tb_hero where hero_name like &#x27;%无%&#x27;;</span><br><span class="line">+---------+-----------+--------------+---------+</span><br><span class="line">| hero_id | hero_name | skill        | book_id |</span><br><span class="line">+---------+-----------+--------------+---------+</span><br><span class="line">|       3 | 张无忌    | 九阳神功     |       3 |</span><br><span class="line">|       5 | 花无缺    | 移花接玉     |       5 |</span><br><span class="line">+---------+-----------+--------------+---------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from tb_hero where hero_name like &#x27;%无%&#x27;;</span><br><span class="line">+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | tb_hero | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    6 |    16.67 | Using where |</span><br><span class="line">+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)`</span><br></pre></td></tr></table></figure>

<p>可以看出全模糊查询时全表扫了，这个时候使用<code>覆盖索引</code>的特性，只选择索引字段可以有所优化。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select book_id, hero_name from tb_hero where hero_name like &#x27;%无%&#x27;;</span><br><span class="line">+----+-------------+---------+------------+-------+---------------+-----------------------+---------+------+------+----------+--------------------------+</span><br><span class="line">| id | select_type | table   | partitions | type  | possible_keys | key                   | key_len | ref  | rows | filtered | Extra                    |</span><br><span class="line">+----+-------------+---------+------------+-------+---------------+-----------------------+---------+------+------+----------+--------------------------+</span><br><span class="line">|  1 | SIMPLE      | tb_hero | NULL       | index | NULL          | idx_book_id_hero_name | 136     | NULL |    6 |    16.67 | Using where; Using index |</span><br><span class="line">+----+-------------+---------+------------+-------+---------------+-----------------------+---------+------+------+----------+--------------------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)`</span><br></pre></td></tr></table></figure>
<h3 id="count"><a href="#count" class="headerlink" title="count(*)"></a>count(*)</h3><p>阿里巴巴Java开发手册中有这样的规约：</p>
<blockquote>
<p>不要使用<code>count(列名)</code>或<code>count(常量)</code>来替代<code>count(*)</code>，<code>count(*)</code>是SQL92定义的标准统计行数的语法，跟数据库无关，跟<code>NULL</code>和<code>非NULL</code>无关【说明：<code>count(*)</code>会统计值为<code>NULL</code>的行，而<code>count(列名)</code>不会统计此列为<code>NULL</code>值的行】。<br><code>count(distinct col)</code>计算该列除<code>NULL</code>之外的不重复行数，注意<code>count(distinct col1, col2)</code>如果其中一列全为<code>NULL</code>，那么即使另一列有不同的值，也返回为0</p>
</blockquote>
<p>截取一段官方文档对<code>count</code>的描述(具体见：<code>https://dev.mysql.com/doc/refman/5.7/en/aggregate-functions.html#function_count</code>)</p>
<blockquote>
<p>COUNT(expr): Returns a count of the number of non-NULL values of expr in the rows.The result is a BIGINT value.If there are no matching rows, COUNT(expr) returns 0.</p>
</blockquote>
<blockquote>
<p>COUNT(*) is somewhat different in that it returns a count of the number of rows, whether or not they contain NULL values.</p>
</blockquote>
<blockquote>
<p>Prior to MySQL 5.7.18, InnoDB processes SELECT <code>COUNT(*)</code> statements by scanning the clustered index. As of MySQL 5.7.18, InnoDB processes SELECT COUNT(*) statements by traversing the smallest available secondary index unless an index or optimizer hint directs the optimizer to use a different index. If a secondary index is not present, the clustered index is scanned.</p>
</blockquote>
<p>可见<code>5.7.18</code>之前，MySQL处理<code>count(*)</code>会扫描主键索引，<code>5.7.18</code>之后从非主键索引中选择较小的合适的索引扫描。可以用<code>explain</code>看下执行计划。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select version();</span><br><span class="line">+-----------+</span><br><span class="line">| version() |</span><br><span class="line">+-----------+</span><br><span class="line">| 5.7.18    |</span><br><span class="line">+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select count(*) from tb_hero;</span><br><span class="line">+----+-------------+---------+------------+-------+---------------+-----------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table   | partitions | type  | possible_keys | key       | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+---------+------------+-------+---------------+-----------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | tb_hero | NULL       | index | NULL          | idx_skill | 15      | NULL |    6 |   100.00 | Using index |</span><br><span class="line">+----+-------------+---------+------------+-------+---------------+-----------+---------+------+------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select count(1) from tb_hero;</span><br><span class="line">+----+-------------+---------+------------+-------+---------------+-----------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table   | partitions | type  | possible_keys | key       | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+---------+------------+-------+---------------+-----------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | tb_hero | NULL       | index | NULL          | idx_skill | 15      | NULL |    6 |   100.00 | Using index |</span><br><span class="line">+----+-------------+---------+------------+-------+---------------+-----------+---------+------+------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)`</span><br></pre></td></tr></table></figure>

<p>有人纠结<code>count(*)</code>、<code>count(1)</code>到底哪种写法更高效，从上面的执行计划来看都一样，如果你还不放心的话，官方文档中也明确指明了<code>InnoDB</code>对<code>count(*)</code>、<code>count(1)</code>的处理完全一致。</p>
<blockquote>
<p>InnoDB handles SELECT COUNT(*) and SELECT COUNT(1) operations in the same way. There is no performance difference.</p>
</blockquote>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>索引列上做任何操作(<code>表达式</code>、<code>函数计算</code>、<code>类型转换</code>等)时无法使用索引会导致全表扫描</p>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>前几周测试同事对公司的某产品进行压测，某单表写入了近2亿条数据，过程中发现配的报表有几个数据查询时间太长，所以重点看了几个慢查询SQL。避免敏感信息，这里对其提取简化做个记录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(*) from tb_alert;</span><br><span class="line">+-----------+</span><br><span class="line">| count(*)  |</span><br><span class="line">+-----------+</span><br><span class="line">| 198101877 |</span><br><span class="line">+-----------+`</span><br></pre></td></tr></table></figure>

<h3 id="表join慢"><a href="#表join慢" class="headerlink" title="表join慢"></a>表join慢</h3><p>表join后，取前10条数据就花了15秒，看了下SQL执行计划，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tb_alert left join tb_situation_alert on tb_alert.alert_id = tb_situation_alert.alert_id limit 10;</span><br><span class="line">10 rows in set (15.46 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from tb_alert left join tb_situation_alert on tb_alert.alert_id = tb_situation_alert.alert_id limit 10;</span><br><span class="line">+----+-------------+--------------------+------------+------+---------------+------+---------+------+-----------+----------+----------------------------------------------------+</span><br><span class="line">| id | select_type | table              | partitions | type | possible_keys | key  | key_len | ref  | rows      | filtered | Extra                                              |</span><br><span class="line">+----+-------------+--------------------+------------+------+---------------+------+---------+------+-----------+----------+----------------------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | tb_alert           | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 190097118 |   100.00 | NULL                                               |</span><br><span class="line">|  1 | SIMPLE      | tb_situation_alert | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   8026988 |   100.00 | Using where; Using join buffer (Block Nested Loop) |</span><br><span class="line">+----+-------------+--------------------+------------+------+---------------+------+---------+------+-----------+----------+----------------------------------------------------+</span><br><span class="line">2 rows in set, 1 warning (0.00 sec)`</span><br></pre></td></tr></table></figure>

<p>可以看出join的时候没有用上索引，<code>tb_situation_alert</code>表上<code>联合主键</code>是这样的<code>PRIMARY KEY (situation_id, alert_id)</code>，参与表join字段是<code>alert_id</code>，原来是不符合联合索引的最左前缀法则，仅从这条sql看，解决方案有两种，一种是对<code>tb_situation_alert</code>表上的<code>alert_id</code>单独建立索引，另外一种是调换联合主键的列的次序，改为<code>PRIMARY KEY (alert_id, situation_id)</code>。当然不能因为多配一张报表，就改其他产线的表的主键索引，这并不合理。在这里，应该对<code>alert_id</code>列单独建立索引。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create index idx_alert_id on tb_situation_alert (alert_id);</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from tb_alert left join tb_situation_alert on tb_alert.alert_id = tb_situation_alert.alert_id limit 100;</span><br><span class="line">100 rows in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from tb_alert left join tb_situation_alert on tb_alert.alert_id = tb_situation_alert.alert_id limit 100;</span><br><span class="line">+----+-------------+--------------------+------------+------+---------------+--------------+---------+---------------------------------+-----------+----------+-------+</span><br><span class="line">| id | select_type | table              | partitions | type | possible_keys | key          | key_len | ref                             | rows      | filtered | Extra |</span><br><span class="line">+----+-------------+--------------------+------------+------+---------------+--------------+---------+---------------------------------+-----------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | tb_alert           | NULL       | ALL  | NULL          | NULL         | NULL    | NULL                            | 190097118 |   100.00 | NULL  |</span><br><span class="line">|  1 | SIMPLE      | tb_situation_alert | NULL       | ref  | idx_alert_id  | idx_alert_id | 8       | tb_alert.alert_id |         2 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+--------------------+------------+------+---------------+--------------+---------+---------------------------------+-----------+----------+-------+</span><br><span class="line">2 rows in set, 1 warning (0.00 sec)`</span><br></pre></td></tr></table></figure>

<p>优化后，执行计划可以看出join的时候走了索引，查询前100条0.01秒，和之前的取前10条数据就花了15秒天壤之别。</p>
<h3 id="分页查询慢"><a href="#分页查询慢" class="headerlink" title="分页查询慢"></a>分页查询慢</h3><p>从第10000000条数据往后翻页时，25秒才能出结果，这里就能使用上面的分页查询优化技巧了。上面讲优化建议时，没看执行计划，这里正好看一下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tb_alert limit 10000000, 10;</span><br><span class="line">10 rows in set (25.23 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from tb_alert limit 10000000, 10;</span><br><span class="line">+----+-------------+----------+------------+------+---------------+------+---------+------+-----------+----------+-------+</span><br><span class="line">| id | select_type | table    | partitions | type | possible_keys | key  | key_len | ref  | rows      | filtered | Extra |</span><br><span class="line">+----+-------------+----------+------------+------+---------------+------+---------+------+-----------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | tb_alert | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 190097118 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+----------+------------+------+---------------+------+---------+------+-----------+----------+-------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)`</span><br></pre></td></tr></table></figure>

<p>再看下使用上分页查询优化技巧的sql的执行计划</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tb_alert a inner join (select alert_id from tb_alert limit 10000000, 10) b on a.alert_id = b.alert_id;</span><br><span class="line">10 rows in set (2.29 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from tb_alert a inner join (select alert_id from tb_alert a2 limit 10000000, 10) b on a.alert_id = b.alert_id;</span><br><span class="line">+----+-------------+------------+------------+--------+---------------+---------------+---------+-----------+-----------+----------+-------------+</span><br><span class="line">| id | select_type | table      | partitions | type   | possible_keys | key           | key_len | ref       | rows      | filtered | Extra       |</span><br><span class="line">+----+-------------+------------+------------+--------+---------------+---------------+---------+-----------+-----------+----------+-------------+</span><br><span class="line">|  1 | PRIMARY     | &lt;derived2&gt; | NULL       | ALL    | NULL          | NULL          | NULL    | NULL      |  10000010 |   100.00 | NULL        |</span><br><span class="line">|  1 | PRIMARY     | a          | NULL       | eq_ref | PRIMARY       | PRIMARY       | 8       | b.alert_id |         1 |   100.00 | NULL        |</span><br><span class="line">|  2 | DERIVED     | a2         | NULL       | index  | NULL          | idx_processed | 5       | NULL      | 190097118 |   100.00 | Using index |</span><br><span class="line">+----+-------------+------------+------------+--------+---------------+---------------+---------+-----------+-----------+----------+-------------+</span><br><span class="line">3 rows in set, 1 warning (0.00 sec)`</span><br></pre></td></tr></table></figure>

<h3 id="分组聚合慢"><a href="#分组聚合慢" class="headerlink" title="分组聚合慢"></a>分组聚合慢</h3><p>分析SQL后，发现根本上并非分组聚合慢，而是扫描联合索引后，回表导致性能低下，去除不必要的字段，使用覆盖索引。</p>
<p>这里避免敏感信息，只演示分组聚合前的简化SQL，主要问题也是在这。<br>表上有联合索引 <code>KEY idx_alert_start_host_template_id ( alert_start, alert_host, template_id)</code>，优化前的sql为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select alert_start, alert_host, template_id, alert_service from tb_alert where alert_start &gt; &#123;ts &#x27;2019-06-05 00:00:10.0&#x27;&#125; limit 10000;</span><br><span class="line">10000 rows in set (1 min 5.22 sec)`</span><br></pre></td></tr></table></figure>

<p>使用覆盖索引，去掉<code>template_id</code>列，就能避免回表，查询时间从1min多变为0.03秒，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select alert_start, alert_host, template_id from tb_alert where alert_start &gt; &#123;ts &#x27;2019-06-05 00:00:10.0&#x27;&#125; limit 10000;</span><br><span class="line">10000 rows in set (0.03 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select alert_start, alert_host, template_id from tb_alert where alert_start &gt; &#123;ts &#x27;2019-06-05 00:00:10.0&#x27;&#125; limit 10000;</span><br><span class="line">+----+-------------+----------+------------+-------+------------------------------------+------------------------------------+---------+------+----------+----------+--------------------------+</span><br><span class="line">| id | select_type | table    | partitions | type  | possible_keys                      | key                                | key_len | ref  | rows     | filtered | Extra                    |</span><br><span class="line">+----+-------------+----------+------------+-------+------------------------------------+------------------------------------+---------+------+----------+----------+--------------------------+</span><br><span class="line">|  1 | SIMPLE      | tb_alert | NULL       | range | idx_alert_start_host_template_id   | idx_alert_start_host_template_id   | 9       | NULL | 95048559 |   100.00 | Using where; Using index |</span><br><span class="line">+----+-------------+----------+------------+-------+------------------------------------+------------------------------------+---------+------+----------+----------+--------------------------+</span><br><span class="line">1 row in set, 1 warning (0.01 sec)`</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>任何不考虑应用场景的设计都不是最好的设计，就比如说表结构的设计、索引的创建，都应该权衡数据量大小、查询需求、数据更新频率等。<br>另外正如 <code>《阿里巴巴java开发手册》</code>中提到的<code>索引规约</code>(详情见：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/itwild/p/12353164.html">《Java开发手册》之”异常处理、MySQL 数据库”</a>)： <code>创建索引时避免有如下极端误解:</code></p>
<blockquote>
<p>1）宁滥勿缺。认为一个查询就需要建一个索引<br>2）宁缺勿滥。认为索引会消耗空间、严重拖慢记录的更新以及行的新增速度</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/107/">107</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Mr.Guan"
      src="/images/header.jpg">
  <p class="site-author-name" itemprop="name">Mr.Guan</p>
  <div class="site-description" itemprop="description">一份耕耘，一份收获</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">319</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">69</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/xguan2014" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xguan2014" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:xguan2014@gmail.com" title="E-Mail → mailto:xguan2014@gmail.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="hhttps://blog.csdn.net/qq_32688731" title="CSDN → hhttps:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_32688731" rel="noopener" target="_blank"><i class="globe fa-fw"></i>CSDN</a>
      </span>
  </div>




  立足江湖：
  <p id="site_time_ing" title="建站日期：2017-05-20 16:46:00"></p>
  <script>
    var starttime = "2017-05-20 16:46:00";
    setInterval(function () { interval(starttime); }, 1000);
    function interval(e) {
        var date1 = new Date(e);  //开始时间
        var date2 = new Date();    //结束时间
        var date3 = date2.getTime() - date1.getTime()  //时间差的毫秒数

        //计算出相差天数
        var days = Math.floor(date3 / (24 * 3600 * 1000))

        //计算出小时数
        var leave1 = date3 % (24 * 3600 * 1000)    //计算天数后剩余的毫秒数
        var hours = Math.floor(leave1 / (3600 * 1000))
        hours = hours > 9 ? hours : '0' + hours

        //计算相差分钟数
        var leave2 = leave1 % (3600 * 1000)        //计算小时数后剩余的毫秒数
        var minutes = Math.floor(leave2 / (60 * 1000))
        minutes = minutes > 9 ? minutes : '0' + minutes

        //计算相差秒数
        var leave3 = leave2 % (60 * 1000)      //计算分钟数后剩余的毫秒数
        var seconds = Math.round(leave3 / 1000)
        seconds = seconds > 9 ? seconds : '0' + seconds

        var countDays = document.getElementById("site_time_ing")
        countDays.innerHTML = days + "天 " + hours + "小时 " + minutes + "分钟 " + seconds + " 秒"
    }
  </script>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="BbeiAn-info">
    <a target="_blank" href="https://beian.miit.gov.cn/#/Integrated/index" rel="nofollow" >鄂ICP备17012779号-1</a> 
	  <a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=42011602000374" style="text-decoration:none;padding-left:25px;background:url(/images/beian.png) no-repeat left center" rel="nofollow">公安备案号 42011602000374</a>
</div>

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="bug"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mr.Guan</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">1.4m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">20:58</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


</body>
</html>
